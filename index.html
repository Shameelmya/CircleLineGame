<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circle Line Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, updateDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // DO NOT EDIT - These global variables are provided by the canvas environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : '';
        
        // IMPORTANT: Paste your Firebase config object here for GitHub hosting!
        const firebaseConfig = {
            apiKey: "AIzaSyDC8lbHuH6sZla2JijW_HU7jcy-YfanUaw",
            authDomain: "crcle-lne-gme.firebaseapp.com",
            projectId: "crcle-lne-gme",
            storageBucket: "crcle-lne-gme.firebasestorage.app",
            messagingSenderId: "710733005551",
            appId: "1:710733005551:web:3edd685a5622c6c4a0911a"
        };
        
        // Firebase initialization and authentication
        let app, db, auth;
        let userId = null;
        let isAuthReady = false;
        let currentGameId = null;
        
        window.addEventListener('load', async () => {
            if (Object.keys(firebaseConfig).length > 0) {
                setLogLevel('debug');
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
        
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log("User signed in with ID:", userId);
                        isAuthReady = true;
                        // Now that auth is ready, we can initialize the game logic
                        initGame();
                    } else {
                        userId = null;
                        isAuthReady = true;
                        console.log("No user signed in.");
                        initGame();
                    }
                });
        
                try {
                    if (initialAuthToken) {
                        await signInWithCustomToken(auth, initialAuthToken);
                        console.log("Signed in with custom token.");
                    } else {
                        await signInAnonymously(auth);
                        console.log("Signed in anonymously.");
                    }
                } catch (error) {
                    console.error("Firebase Auth Error:", error);
                }
            } else {
                console.error("Firebase config is missing. Game cannot be played online.");
            }
        });
        
        // --- Game Logic ---
        const rows = 10;
        const playerColors = {
            'player1': { line: 'pink', fill: 'bg-gray-400', name: '' },
            'player2': { line: 'purple', fill: 'bg-gray-400', name: '' }
        };
        
        // Helper function to generate a random room code
        function generateRoomCode() {
            const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let result = '';
            for (let i = 0; i < 5; i++) {
                result += characters.charAt(Math.floor(Math.random() * characters.length));
            }
            return result;
        }

        const gameRef = (gameId) => doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
        
        function initGame() {
            if (!isAuthReady) {
                console.log("Authentication not ready. Retrying initGame...");
                setTimeout(initGame, 500);
                return;
            }
            
            // Always show the name/room modal first
            document.getElementById('game-container').classList.add('hidden');
            document.getElementById('name-modal').classList.remove('hidden');
        }

        // Sets up the Firestore listener and starts the game
        function setupGameListener() {
            onSnapshot(gameRef(currentGameId), async (docSnap) => {
                const gameState = docSnap.data();
                if (!gameState) {
                    console.log("No game state found, waiting for player 1 to create it.");
                    return;
                }
                
                // Assign a turn if both players are present
                if (gameState.player1Id && gameState.player2Id && gameState.playerTurn === null) {
                    await updateDoc(gameRef(currentGameId), {
                        playerTurn: Math.random() < 0.5 ? 'player1' : 'player2'
                    });
                    console.log("Initial turn assigned.");
                }
    
                if (typeof gameState.circles === 'string') {
                    gameState.circles = JSON.parse(gameState.circles);
                }
                renderGame(gameState);
            });
        }
        
        async function createRoom() {
            const playerName = document.getElementById('player-name-input').value.trim();
            if (!playerName) {
                showMessage("Please enter your name.", 'red');
                return;
            }

            const roomCode = generateRoomCode();
            currentGameId = roomCode;

            let circles = [];
            let count = 0;
            for (let i = rows - 1; i >= 0; i--) {
                const row = [];
                for (let j = 0; j <= i; j++) {
                    row.push({
                        filled: false,
                        filledBy: null,
                        id: `circle-${count++}`
                    });
                }
                circles.push(row);
            }

            const newGameState = {
                circles: JSON.stringify(circles),
                scores: { player1: 0, player2: 0 },
                playerTurn: null,
                player1Id: userId,
                player2Id: null,
                player1Name: playerName,
                player2Name: null,
                lines: []
            };
            try {
                await setDoc(gameRef(currentGameId), newGameState);
                console.log(`New game created with room code: ${roomCode}`);
                document.getElementById('name-modal').classList.add('hidden');
                document.getElementById('game-container').classList.remove('hidden');
                setupGameListener();
                showMessage(`Room created! Share this code with a friend: ${roomCode}`, 'green');
            } catch (e) {
                console.error("Error setting initial game state:", e);
                showMessage("Failed to create room. Please try again.", 'red');
            }
        }

        async function joinRoom() {
            const playerName = document.getElementById('player-name-input').value.trim();
            const roomCode = document.getElementById('room-code-input').value.trim().toUpperCase();
            if (!playerName || !roomCode) {
                showMessage("Please enter your name and a room code.", 'red');
                return;
            }

            currentGameId = roomCode;
            const docSnap = await getDoc(gameRef(currentGameId));

            if (!docSnap.exists()) {
                showMessage("Room not found.", 'red');
                return;
            }

            const gameState = docSnap.data();
            if (gameState.player1Id === userId || gameState.player2Id === userId) {
                showMessage("You are already in this game.", 'yellow');
                document.getElementById('name-modal').classList.add('hidden');
                document.getElementById('game-container').classList.remove('hidden');
                setupGameListener();
                return;
            }

            if (gameState.player2Id) {
                showMessage("This room is already full.", 'red');
                return;
            }

            try {
                await updateDoc(gameRef(currentGameId), {
                    player2Id: userId,
                    player2Name: playerName,
                });
                console.log(`Joined room ${roomCode} as Player 2.`);
                document.getElementById('name-modal').classList.add('hidden');
                document.getElementById('game-container').classList.remove('hidden');
                setupGameListener();
            } catch (e) {
                console.error("Error joining room:", e);
                showMessage("Failed to join room. Please try again.", 'red');
            }
        }
        
        document.getElementById('create-room-button').addEventListener('click', createRoom);
        document.getElementById('join-room-button').addEventListener('click', joinRoom);
        
        async function handleCircleClick(circleId, rowIdx, colIdx) {
            if (!userId) {
                showMessage("Please wait for authentication to complete.", 'yellow');
                return;
            }
        
            const docSnap = await getDoc(gameRef(currentGameId));
            if (!docSnap.exists()) return;
        
            const gameState = docSnap.data();
            if (typeof gameState.circles === 'string') {
                gameState.circles = JSON.parse(gameState.circles);
            }
            
            // Determine my player role
            let myPlayerRole = null;
            if (gameState.player1Id === userId) {
                myPlayerRole = 'player1';
            } else if (gameState.player2Id === userId) {
                myPlayerRole = 'player2';
            } else {
                showMessage("The game is full. You are a spectator.", 'red');
                return;
            }
        
            // Check if it's my turn
            if (gameState.playerTurn !== myPlayerRole) {
                showMessage(`It's not your turn!`, 'red');
                return;
            }
        
            // Check if the circle is already filled
            const circle = gameState.circles[rowIdx][colIdx];
            if (circle.filled) {
                showMessage("This circle is already filled.", 'red');
                return;
            }
            
            // Update the circle's state
            gameState.circles[rowIdx][colIdx].filled = true;
            gameState.circles[rowIdx][colIdx].filledBy = myPlayerRole;
        
            // Check for completed lines
            let newLines = checkLines(gameState.circles, gameState.lines);
            
            // Apply new lines and update scores
            if (newLines.length > 0) {
                newLines.forEach(line => {
                    gameState.scores[myPlayerRole] += line.points;
                    gameState.lines.push({ type: line.type, points: line.points, player: myPlayerRole });
                });
                showMessage(`Player ${myPlayerRole.slice(-1)} connected a line and got ${newLines[0].points} points! You get another turn.`, 'green');
            } else {
                // Change turn only if no line was connected
                gameState.playerTurn = gameState.playerTurn === 'player1' ? 'player2' : 'player1';
            }
        
            // Save the updated state to Firestore
            try {
                await setDoc(gameRef(currentGameId), { ...gameState, circles: JSON.stringify(gameState.circles) });
            } catch (e) {
                console.error("Error updating game state:", e);
            }
        }
        
        function checkLines(circles, existingLines) {
            const newLines = [];
        
            // Horizontal lines
            for (let i = 0; i < circles.length; i++) {
                const row = circles[i];
                if (row.every(c => c.filled)) {
                    if (!existingLines.some(l => l.type === `horizontal-${i}`)) {
                        newLines.push({ type: `horizontal-${i}`, points: row.length });
                    }
                }
            }
        
            // Diagonal Right lines
            for (let i = 0; i < circles.length; i++) {
                let diagonalRight = [];
                for (let j = 0; j < circles[i].length; j++) {
                    if (circles[i][j]) {
                         let row = i;
                         let col = j;
                         let line = [];
                         while(circles[row] && circles[row][col]) {
                             line.push(circles[row][col]);
                             row++;
                             col++;
                         }
                         if (line.length > 1 && line.every(c => c.filled)) {
                             const lineId = `diagR-${line[0].id}`;
                             if (!existingLines.some(l => l.type === lineId)) {
                                 newLines.push({ type: lineId, points: line.length });
                             }
                         }
                    }
                }
            }
        
            // Diagonal Left lines
            for (let i = 0; i < circles.length; i++) {
                let diagonalLeft = [];
                for (let j = 0; j < circles[i].length; j++) {
                    if (circles[i][j]) {
                         let row = i;
                         let col = j;
                         let line = [];
                         while(circles[row] && circles[row][col]) {
                             line.push(circles[row][col]);
                             row++;
                             col--;
                         }
                         if (line.length > 1 && line.every(c => c.filled)) {
                             const lineId = `diagL-${line[0].id}`;
                             if (!existingLines.some(l => l.type === lineId)) {
                                 newLines.push({ type: lineId, points: line.length });
                             }
                         }
                    }
                }
            }
        
            return newLines;
        }
        
        // --- UI Rendering ---
        function renderGame(gameState) {
            const gameBoard = document.getElementById('game-board');
            gameBoard.innerHTML = '';
            
            const circleDiameter = 30;
            const gap = 15;
            const horizontalSpacing = circleDiameter + gap;
            const verticalSpacing = (circleDiameter + gap) * Math.sqrt(3) / 2;
        
            gameState.circles.forEach((row, rowIdx) => {
                const rowLength = row.length;
                const rowWidth = (rowLength - 1) * horizontalSpacing;
                const rowXOffset = -rowWidth / 2;
        
                row.forEach((circle, colIdx) => {
                    const circleDiv = document.createElement('div');
                    circleDiv.id = circle.id;
        
                    const xPos = rowXOffset + (colIdx * horizontalSpacing);
                    const yPos = rowIdx * verticalSpacing;
        
                    circleDiv.className = `absolute w-[30px] h-[30px] rounded-full border-2 border-slate-500 cursor-pointer transition-colors duration-200 ${circle.filled ? (circle.filledBy === 'player1' ? 'bg-pink-500' : 'bg-purple-500') : 'bg-gray-400'}`;
                    circleDiv.style.left = `calc(50% + ${xPos}px)`;
                    circleDiv.style.top = `${yPos}px`;
        
                    circleDiv.addEventListener('click', () => handleCircleClick(circle.id, rowIdx, colIdx));
                    gameBoard.appendChild(circleDiv);
                });
            });
            
            // Render lines
            gameState.lines.forEach(line => {
                const lineDiv = document.createElement('div');
                lineDiv.className = `absolute z-10`;
                
                const lineType = line.type.split('-')[0];
                const playerColor = line.player === 'player1' ? playerColors.player1.line : playerColors.player2.line;
        
                if (lineType === 'horizontal') {
                    const rowIdx = parseInt(line.type.split('-')[1]);
                    const firstCircle = document.getElementById(gameState.circles[rowIdx][0].id);
                    const lastCircle = document.getElementById(gameState.circles[rowIdx][gameState.circles[rowIdx].length - 1].id);
                    
                    const startRect = firstCircle.getBoundingClientRect();
                    const endRect = lastCircle.getBoundingClientRect();
                    const boardRect = gameBoard.getBoundingClientRect();
        
                    const startX = startRect.left + startRect.width / 2 - boardRect.left;
                    const startY = startRect.top + startRect.height / 2 - boardRect.top;
                    const endX = endRect.left + endRect.width / 2 - boardRect.left;
                    
                    const width = endX - startX;
                    
                    lineDiv.style.left = `${startX}px`;
                    lineDiv.style.top = `${startY}px`;
                    lineDiv.style.width = `${width}px`;
                    lineDiv.style.height = `3px`;
                    lineDiv.style.backgroundColor = playerColor;
                    lineDiv.style.transformOrigin = 'left center';
                } else if (lineType === 'diagR' || lineType === 'diagL') {
                    const circleId = line.type.split('-')[1];
                    const startCircle = document.getElementById(circleId);
                    if (!startCircle) return;
        
                    let rowIdx = -1, colIdx = -1;
                    outerLoop:
                    for(let i=0; i<gameState.circles.length; i++) {
                        for(let j = 0; j < gameState.circles[i].length; j++) {
                            if (gameState.circles[i][j].id === circleId) {
                                rowIdx = i;
                                colIdx = j;
                                break outerLoop;
                            }
                        }
                    }
        
                    let endRow = rowIdx;
                    let endCol = colIdx;
                    while(gameState.circles[endRow] && gameState.circles[endRow][endCol]) {
                        endRow++;
                        if (lineType === 'diagR') endCol++;
                        else endCol--;
                    }
                    endRow--;
                    if (lineType === 'diagR') endCol--;
                    else endCol++;
        
                    const endCircle = document.getElementById(gameState.circles[endRow][endCol].id);
                    if (!endCircle) return;
        
                    const startRect = startCircle.getBoundingClientRect();
                    const endRect = endCircle.getBoundingClientRect();
                    const boardRect = gameBoard.getBoundingClientRect();
        
                    const startX = startRect.left + startRect.width / 2 - boardRect.left;
                    const startY = startRect.top + startRect.height / 2 - boardRect.top;
                    const endX = endRect.left + endRect.width / 2 - boardRect.left;
                    const endY = endRect.top + endRect.height / 2 - boardRect.top;
        
                    const length = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                    const angle = Math.atan2(endY - startY, endX - startX) * 180 / Math.PI;
        
                    lineDiv.style.left = `${startX}px`;
                    lineDiv.style.top = `${startY}px`;
                    lineDiv.style.width = `${length}px`;
                    lineDiv.style.height = `3px`;
                    lineDiv.style.backgroundColor = playerColor;
                    lineDiv.style.transformOrigin = 'left center';
                    lineDiv.style.transform = `rotate(${angle}deg)`;
                }
                gameBoard.appendChild(lineDiv);
            });
            
            // Update UI elements
            const turnText = document.getElementById('turn-text');
            const scoreP1 = document.getElementById('score-player1');
            const scoreP2 = document.getElementById('score-player2');
            const userIdDisplay = document.getElementById('user-id-display');
            
            userIdDisplay.textContent = `Room ID: ${currentGameId}`;
            
            const player1Name = gameState.player1Name || 'Player 1';
            const player2Name = gameState.player2Name || 'Player 2';
            
            playerColors.player1.name = player1Name;
            playerColors.player2.name = player2Name;
        
            if (gameState.playerTurn) {
                const myRole = (gameState.player1Id === userId) ? 'player1' : (gameState.player2Id === userId ? 'player2' : null);
                if (gameState.playerTurn === myRole) {
                    turnText.textContent = `It's your turn!`;
                } else {
                    const opponentName = (gameState.playerTurn === 'player1') ? player1Name : player2Name;
                    turnText.textContent = `It's ${opponentName}'s turn.`;
                }
                turnText.className = `text-base sm:text-lg font-bold ${gameState.playerTurn === 'player1' ? 'text-pink-500' : 'text-purple-500'}`;
            } else {
                turnText.textContent = 'Waiting for another player...';
                turnText.className = 'text-base sm:text-lg font-bold text-slate-400';
            }
        
            scoreP1.textContent = `${player1Name}: ${gameState.scores.player1} points`;
            scoreP2.textContent = `${player2Name}: ${gameState.scores.player2} points`;
        }
        
        function showMessage(message, color) {
            const messageDiv = document.getElementById('message-modal');
            const messageText = document.getElementById('message-text');
            messageText.textContent = message;
            messageText.className = `text-${color}-500`;
            messageDiv.classList.remove('hidden');
            setTimeout(() => {
                messageDiv.classList.add('hidden');
            }, 5000);
        }
        
        document.getElementById('close-message').addEventListener('click', () => {
            document.getElementById('message-modal').classList.add('hidden');
        });
        
        async function resetGame() {
            if (!userId) {
                showMessage("Please wait for authentication to complete.", 'yellow');
                return;
            }
            const docSnap = await getDoc(gameRef(currentGameId));
            if (docSnap.exists()) {
                const gameState = docSnap.data();
                if (gameState.player1Id !== userId) {
                    showMessage("Only the room creator can reset the game.", 'red');
                    return;
                }
            }
        
            let circles = [];
            let count = 0;
            // The row generation has been inverted to create a triangle pointing up
            for (let i = rows - 1; i >= 0; i--) {
                const row = [];
                for (let j = 0; j <= i; j++) {
                    row.push({
                        filled: false,
                        filledBy: null,
                        id: `circle-${count++}`
                    });
                }
                circles.push(row);
            }
        
            const newGameState = {
                circles: JSON.stringify(circles),
                scores: { player1: 0, player2: 0 },
                playerTurn: null,
                player1Id: userId,
                player2Id: null,
                player1Name: gameState.player1Name,
                player2Name: null,
                lines: []
            };
        
            try {
                await setDoc(gameRef(currentGameId), newGameState);
                console.log("Game reset by Player 1.");
                showMessage("Game has been reset!", 'green');
            } catch (e) {
                console.error("Error resetting game state:", e);
            }
        }
        
        document.getElementById('reset-button').addEventListener('click', resetGame);

        // --- Confirmation Modal for Navigation ---
        let startY = 0;
        const confirmationModal = document.getElementById('confirmation-modal');

        // Prevent pull-to-refresh on mobile
        document.body.addEventListener('touchstart', (e) => {
            startY = e.touches[0].pageY;
        });

        document.body.addEventListener('touchmove', (e) => {
            const currentY = e.touches[0].pageY;
            // Check if the user is dragging down near the top of the page
            if (currentY > startY + 5 && window.scrollY === 0) {
                e.preventDefault();
                showConfirmationModal();
            }
        }, { passive: false }); // `passive: false` is required to call `preventDefault`

        // Show confirmation on back button press
        window.addEventListener('popstate', (e) => {
            history.pushState(null, null, location.href);
            showConfirmationModal();
        });

        function showConfirmationModal() {
            if (currentGameId) {
                confirmationModal.classList.remove('hidden');
            }
        }
        
        document.getElementById('confirm-leave').addEventListener('click', () => {
            // User confirms leaving, so allow navigation
            history.back();
        });
        
        document.getElementById('cancel-leave').addEventListener('click', () => {
            // User cancels, hide the modal and stay on the page
            confirmationModal.classList.add('hidden');
        });

        </script>
    <style>
        body {
            /* Prevent scrolling on mobile devices */
            overflow: hidden;
        }

        .circle-container {
            position: relative;
            /* Adjust height to fit the inverted triangle */
            height: 400px;
            width: 400px;
        }
    </style>
</head>
<body class="bg-slate-900 text-slate-100 font-sans p-4 sm:p-8 flex items-center justify-center min-h-screen">
    <div class="max-w-4xl mx-auto flex flex-col items-center px-4 sm:px-8 md:px-12">
        <h1 class="text-3xl sm:text-4xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-pink-500 to-purple-500 mb-4">Circle Line Game</h1>

        <!-- User ID display -->
        <p id="user-id-display" class="text-xs mb-4 text-slate-400 text-center break-all"></p>
        
        <div id="game-container" class="flex flex-col items-center">
            <!-- Scoreboard -->
            <div class="flex justify-around w-full mb-6 text-base sm:text-lg font-semibold">
                <p id="score-player1" class="text-pink-500">Player 1: 0 points</p>
                <p id="score-player2" class="text-purple-500">Player 2: 0 points</p>
            </div>
    
            <!-- Player Turn Display -->
            <div class="mb-6">
                <p id="turn-text" class="text-lg font-bold"></p>
            </div>
            
            <!-- Game Board -->
            <div id="game-board" class="circle-container flex flex-col items-center">
                <!-- Circles will be dynamically generated here -->
            </div>
    
            <!-- Reset Button -->
            <button id="reset-button" class="mt-8 bg-purple-500 text-white font-bold py-2 px-4 rounded-full hover:bg-purple-600 transition-colors">
                Reset Game
            </button>
        </div>

        <!-- Name Modal -->
        <div id="name-modal" class="fixed inset-0 bg-slate-900 bg-opacity-75 flex items-center justify-center">
            <div class="bg-slate-800 p-8 rounded-xl shadow-lg border-2 border-slate-700 max-w-sm w-full text-center">
                <h2 class="text-2xl font-bold mb-4">Play Online</h2>
                <p class="text-sm text-slate-400 mb-6">Create a new room or join an existing one to play with a friend.</p>
                <input type="text" id="player-name-input" placeholder="Enter your name" class="w-full p-2 mb-4 rounded bg-slate-700 text-slate-200 border border-slate-600">
                <div class="flex flex-col sm:flex-row gap-4 justify-center">
                    <button id="create-room-button" class="bg-pink-500 text-white font-bold py-2 px-4 rounded-full hover:bg-pink-600 transition-colors">
                        Create Room
                    </button>
                    <input type="text" id="room-code-input" placeholder="Enter room code" class="w-full sm:w-1/2 p-2 rounded bg-slate-700 text-slate-200 border border-slate-600 uppercase">
                    <button id="join-room-button" class="bg-purple-500 text-white font-bold py-2 px-4 rounded-full hover:bg-purple-600 transition-colors">
                        Join Room
                    </button>
                </div>
            </div>
        </div>

        <!-- Message Modal -->
        <div id="message-modal" class="fixed inset-0 bg-slate-900 bg-opacity-75 flex items-center justify-center hidden">
            <div class="bg-slate-800 p-8 rounded-xl shadow-lg border-2 border-slate-700 max-w-sm w-full text-center">
                <p id="message-text" class="text-xl font-semibold mb-4"></p>
                <button id="close-message" class="bg-pink-500 text-white font-bold py-2 px-4 rounded-full hover:bg-pink-600 transition-colors">
                    OK
                </button>
            </div>
        </div>

        <!-- Confirmation Modal for Back/Refresh -->
        <div id="confirmation-modal" class="fixed inset-0 bg-slate-900 bg-opacity-75 flex items-center justify-center hidden">
            <div class="bg-slate-800 p-8 rounded-xl shadow-lg border-2 border-slate-700 max-w-sm w-full text-center">
                <p class="text-xl font-semibold mb-4 text-slate-200">Are you sure you want to leave?</p>
                <p class="text-sm text-slate-400 mb-6">You will lose your current game connection.</p>
                <div class="flex justify-center gap-4">
                    <button id="cancel-leave" class="bg-pink-500 text-white font-bold py-2 px-4 rounded-full hover:bg-pink-600 transition-colors w-full">
                        Cancel
                    </button>
                    <button id="confirm-leave" class="bg-gray-500 text-white font-bold py-2 px-4 rounded-full hover:bg-gray-600 transition-colors w-full">
                        Leave Game
                    </button>
                </div>
            </div>
        </div>
        
    </div>
</body>
</html>
